name: CI Demo - mirrord vs Baseline

on:
  push:
    branches:
      - demo/ci-mirrord
  workflow_dispatch:

concurrency:
  group: ci-demo-mirrord-${{ github.ref }}
  cancel-in-progress: true

jobs:
  baseline-kind:
    name: Baseline (kind - Slow)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Install kind, kubectl, jq
        run: |
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
          
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl
          
          sudo apt-get update && sudo apt-get install -y jq

      - name: Create kind cluster
        run: |
          cat <<EOF | kind create cluster --config=- --name ci-demo-${{ github.sha }}
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
            extraPortMappings:
            - containerPort: 30080
              hostPort: 30080
              protocol: TCP
          EOF
          
          kubectl cluster-info

      - name: Build Docker images
        run: |
          export IMAGE_TAG="ci-demo-${{ github.sha }}"
          
          # Build ip-visit-counter
          docker build -t ip-visit-counter:${IMAGE_TAG} -f apps/ip-visit/ip-visit-counter/Dockerfile .
          
          # Build ip-info (use ip-info directory as build context to match Dockerfile expectations)
          docker build -t ip-info:${IMAGE_TAG} -f apps/ip-visit/ip-info/Dockerfile apps/ip-visit/ip-info/
          
          # Build ip-info-grpc
          docker build -t ip-info-grpc:${IMAGE_TAG} -f apps/ip-visit/ip-info-grpc/Dockerfile .
          
          # Note: Redis and Kafka use pre-built images from registry

      - name: Load images into kind
        run: |
          export IMAGE_TAG="ci-demo-${{ github.sha }}"
          export CLUSTER_NAME="ci-demo-${{ github.sha }}"
          
          kind load docker-image ip-visit-counter:${IMAGE_TAG} --name ${CLUSTER_NAME}
          kind load docker-image ip-info:${IMAGE_TAG} --name ${CLUSTER_NAME}
          kind load docker-image ip-info-grpc:${IMAGE_TAG} --name ${CLUSTER_NAME}

      - name: Create namespace
        run: |
          kubectl apply -f manifests/infrastructure/namespaces.yaml

      - name: Deploy Redis
        run: |
          kubectl apply -k manifests/ip-visit/base/infra/redis -n ip-visit-counter
          # Wait a moment for the deployment object to be available
          sleep 2
          kubectl rollout status deployment/redis-main --namespace=ip-visit-counter --timeout=5m

      - name: Deploy Kafka
        run: |
          kubectl apply -k manifests/ip-visit/base/infra/kafka -n ip-visit-counter
          # Wait a moment for the statefulset object to be available
          sleep 2
          kubectl rollout status statefulset/kafka --namespace=ip-visit-counter --timeout=10m
          # Kafka may need extra time to initialize
          sleep 10

      - name: Deploy ip-info
        run: |
          kubectl apply -k manifests/ip-visit/base/app/ip-info -n ip-visit-counter
          # Wait a moment for the deployment object to be available
          sleep 2
          kubectl set image deployment/ip-info main=ip-info:ci-demo-${{ github.sha }} --namespace=ip-visit-counter
          
          # Check pod status before waiting for rollout
          echo "=== Pod status before rollout ==="
          kubectl get pods -n ip-visit-counter -l app=ip-info || true
          
          # Try rollout status with timeout
          if ! kubectl rollout status deployment/ip-info --namespace=ip-visit-counter --timeout=5m; then
            echo "=== Rollout failed, checking pod status ==="
            kubectl get pods -n ip-visit-counter -l app=ip-info || true
            echo ""
            echo "=== Pod events ==="
            kubectl get events -n ip-visit-counter --sort-by='.lastTimestamp' | grep ip-info | tail -10 || true
            echo ""
            echo "=== Pod describe ==="
            kubectl describe pods -n ip-visit-counter -l app=ip-info | tail -30 || true
            exit 1
          fi

      - name: Deploy ip-info-grpc
        run: |
          kubectl apply -k manifests/ip-visit/base/app/ip-info-grpc -n ip-visit-counter
          # Wait a moment for the deployment object to be available
          sleep 2
          kubectl set image deployment/ip-info-grpc main=ip-info-grpc:ci-demo-${{ github.sha }} --namespace=ip-visit-counter
          kubectl rollout status deployment/ip-info-grpc --namespace=ip-visit-counter --timeout=5m

      - name: Deploy ip-visit-counter
        run: |
          # Apply kind overlay (includes patches for imagePullPolicy and NodePort)
          kubectl apply -k overlays/kind -n ip-visit-counter
          
          # Wait a moment for the deployment object to be available
          sleep 2
          
          # Set image tag
          kubectl set image deployment/ip-visit-counter main=ip-visit-counter:ci-demo-${{ github.sha }} --namespace=ip-visit-counter
          
          # Wait for rollout
          kubectl rollout status deployment/ip-visit-counter --namespace=ip-visit-counter --timeout=5m

      - name: Verify service is accessible
        run: |
          kubectl get svc ip-visit-counter --namespace=ip-visit-counter
          # Wait a moment for service to be ready
          sleep 5

      - name: Run E2E test
        env:
          PLAYGROUND_URL: http://localhost:30080
          DEMO_TENANT: mirrord-ci-demo
        run: |
          chmod +x apps/ip-visit/ip-visit-counter/ci/demo_e2e.sh
          ./apps/ip-visit/ip-visit-counter/ci/demo_e2e.sh

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: baseline-logs
          path: |
            /tmp/kind-*.log

      - name: Delete kind cluster
        if: always()
        run: |
          kind delete cluster --name ci-demo-${{ github.sha }} || true

  mirrord-ci:
    name: mirrord CI (GKE - Fast)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Install build dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y gcc build-essential

      - name: Install jq
        run: |
          sudo apt-get update && sudo apt-get install -y jq

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/kubectl

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_BASE64 }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl get ns ip-visit-counter >/dev/null

      - name: Install mirrord
        run: |
          curl -fsSL https://raw.githubusercontent.com/metalbear-co/mirrord/main/scripts/install.sh | bash
          mirrord --version
          # Verify version >= 3.181.0

      - name: Start mirrord CI
        env:
          MIRRORD_CI_API_KEY: ${{ secrets.MIRRORD_CI_API_KEY }}
          CGO_ENABLED: "1"
        run: |
          echo "=== Verifying CGO and build configuration ==="
          echo "CGO_ENABLED: $CGO_ENABLED"
          go env CGO_ENABLED || echo "go env failed"
          echo ""
          echo "=== Checking if gcc is available ==="
          which gcc || echo "gcc not found"
          gcc --version | head -1 || echo "gcc version check failed"
          echo ""
          
          # Build the binary with dynamic linking flags
          # Use -linkmode=external to force external linking (dynamic)
          echo "=== Building binary with dynamic linking ==="
          go build -ldflags="-linkmode=external" -o /tmp/ip-visit-counter \
            apps/ip-visit/ip-visit-counter/main.go
          
          # Verify the binary is dynamically linked
          echo "=== Verifying binary linking ==="
          if command -v ldd >/dev/null 2>&1; then
            echo "Checking binary with ldd:"
            ldd /tmp/ip-visit-counter 2>&1 | head -10
            if ldd /tmp/ip-visit-counter 2>&1 | grep -q "not a dynamic"; then
              echo "❌ Binary is statically linked"
            else
              echo "✅ Binary appears to be dynamically linked"
            fi
          else
            echo "ldd not available, checking file type:"
            file /tmp/ip-visit-counter
          fi
          echo ""
          
          # Run with mirrord
          mirrord ci start --config-file .mirrord/mirrord-ci.json -- \
            /tmp/ip-visit-counter
          
          # Wait for the application to be ready (it prints "loaded" when ready)
          echo "Waiting for application to start..."
          timeout=60
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if [ -d /tmp/mirrord ]; then
              # Check if "loaded" appears in stdout
              if find /tmp/mirrord -name "stdout" -type f -exec grep -q "loaded" {} \; 2>/dev/null; then
                echo "✅ Application is ready!"
                echo ""
                echo "=== Checking if process is dynamically linked ==="
                # Find the ip-visit-counter process
                GO_PID=$(pgrep -f "ip-visit-counter" | head -1)
                if [ -n "$GO_PID" ]; then
                  echo "Go process PID: $GO_PID"
                  echo "Checking linked libraries:"
                  # Check if process has dynamic libraries (non-static)
                  if [ -f "/proc/$GO_PID/maps" ]; then
                    # Count dynamic library mappings (should be > 0 for dynamic binary)
                    DYNAMIC_COUNT=$(grep -c "\.so" /proc/$GO_PID/maps 2>/dev/null || echo "0")
                    echo "Dynamic library mappings found: $DYNAMIC_COUNT"
                    if [ "$DYNAMIC_COUNT" -gt 0 ]; then
                      echo "✅ Process appears to be dynamically linked"
                      echo "Sample libraries:"
                      grep "\.so" /proc/$GO_PID/maps 2>/dev/null | head -5
                    else
                      echo "❌ WARNING: Process appears to be statically linked (no .so files found)"
                    fi
                  fi
                else
                  echo "Could not find ip-visit-counter process"
                fi
                
                echo ""
                echo "=== Printing mirrord CI output ==="
                if [ -d /tmp/mirrord ]; then
                  echo "Contents of /tmp/mirrord:"
                  find /tmp/mirrord -type f 2>/dev/null | head -10
                  echo ""
                  echo "=== Application stdout ==="
                  find /tmp/mirrord -name "stdout" -type f 2>/dev/null | while read file; do
                    echo "--- $file ---"
                    cat "$file" 2>/dev/null || echo "Could not read $file"
                    echo ""
                  done
                  echo "=== Application stderr ==="
                  find /tmp/mirrord -name "stderr" -type f 2>/dev/null | while read file; do
                    echo "--- $file ---"
                    cat "$file" 2>/dev/null || echo "Could not read $file"
                    echo ""
                  done
                else
                  echo "Directory /tmp/mirrord does not exist"
                fi
                
                echo ""
                echo "=== Waiting 10 seconds for application to fully start ==="
                sleep 10
                echo "✅ Ready to run E2E test"
                
                break
              fi
            fi
            sleep 1
            elapsed=$((elapsed + 1))
            if [ $((elapsed % 5)) -eq 0 ]; then
              echo "Still waiting... (${elapsed}s)"
            fi
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "❌ ERROR: Application did not start within ${timeout} seconds"
            echo "=== Checking logs ==="
            find /tmp/mirrord -type f -name "stdout" -o -name "stderr" 2>/dev/null | while read file; do
              echo "--- $file (last 20 lines) ---"
              tail -20 "$file" 2>/dev/null || echo "Could not read $file"
            done
            exit 1
          fi

      - name: Run E2E test
        env:
          PLAYGROUND_URL: https://playground.metalbear.dev
          DEMO_TENANT: mirrord-ci-demo
        run: |
          chmod +x apps/ip-visit/ip-visit-counter/ci/demo_e2e.sh
          ./apps/ip-visit/ip-visit-counter/ci/demo_e2e.sh

      - name: Stop mirrord CI session
        if: always()
        run: |
          mirrord ci stop || true

      - name: Upload mirrord logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mirrord-logs
          path: /tmp/mirrord
